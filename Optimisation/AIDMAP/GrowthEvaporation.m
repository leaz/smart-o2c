function [ListNodes, BestSolution] = GrowthEvaporation(Inputs, ListNodes, Solutions, BestSolution)% This function finds the best chain of veins used by the agents and% increases the radius of these vains by a pre-specified factor%% Inputs:% * Inputs         : Structure containing the PhysarumSolver inputs% * ListNodes      : Structure containing the graph% * Solutions      : Structure containing the solutions so far%% Outputs: % * ListNodes       : Structure containing the updated graph%% Author: Aram Vroom - 2016% Email:  aram.vroom@strath.ac.uk%%%%%Growth Factor%%%%Loop over the solutions and find the number of nodes and costsnumberofnodes = zeros(1,length(Solutions.Nodes));costs = zeros(1,length(Solutions.Nodes));for i = 1:length(Solutions.Nodes)    numberofnodes(i) = length(Solutions.Nodes{i});    costs(i) = sum(Solutions.Costs{i});end%Retrieve the best chain of nodes[bestchainindex, bestcost] = Inputs.BestChainFile(numberofnodes,costs);%Save best solution found. Loop is used in case multiple solutions are%foudn to be the bestfor i = 1:length(bestcost)BestSolution.BestChain{i} = Solutions.Nodes{bestchainindex(i)};BestSolution.BestCost{i} = bestcost(i);end%Print the best solution so fardisp('-------------------------------------------------------')disp(['The best chain so far has ',num2str(length(BestSolution.BestChain{1})),' nodes and a cost of ',num2str(bestcost(1))]);disp('-------------------------------------------------------')%Loop over the nodes in this chainfor j = 1:length(bestcost)    bestchain = BestSolution.BestChain{j};    for i = 1:length(bestchain)        %For ease of reading, define the node currently being evaluated & its parent        %as a separate variable        evaluatednode = char(bestchain(i));        parent = ListNodes.(evaluatednode).parent;        %Check if the node has a parent - Ignores root        if ~isempty(parent)            %Dilate the respective link in the parent's node structure            ListNodes.(evaluatednode).radius = ListNodes.(evaluatednode).radius + Inputs.GrowthFactor*ListNodes.(evaluatednode).radius;            %Check if the link's radius is not too large or small. Correct if            %so, set to min/max radius            ListNodes.(evaluatednode).radius(ListNodes.(evaluatednode).radius./Inputs.StartingRadius > Inputs.MaximumRadiusRatio) = Inputs.MaximumRadiusRatio*Inputs.StartingRadius;            ListNodes.(evaluatednode).radius(ListNodes.(evaluatednode).radius./Inputs.StartingRadius < Inputs.MinimumRadiusRatio) = Inputs.MinimumRadiusRatio*Inputs.StartingRadius;        end    endend%%%%%Evaporation%%%%allnodes = fieldnames(ListNodes);for i = 1:length(allnodes)    %For ease of reading, define the node currently being evaluated & its parent    %as a separate variable    evaluatednode = char(allnodes(i));    parent = ListNodes.(evaluatednode).parent;    if ~isempty(parent)        %Simulate evaporation in this link            ListNodes.(evaluatednode).radius = ListNodes.(evaluatednode).radius - Inputs.EvaporationCoefficient*ListNodes.(evaluatednode).radius;                %Check if the link's radius is not too large or small. Correct if        %so, set to max/min radius        ListNodes.(evaluatednode).radius(ListNodes.(evaluatednode).radius./Inputs.StartingRadius > Inputs.MaximumRadiusRatio) = Inputs.MaximumRadiusRatio*Inputs.StartingRadius;        ListNodes.(evaluatednode).radius(ListNodes.(evaluatednode).radius./Inputs.StartingRadius < Inputs.MinimumRadiusRatio) = Inputs.MinimumRadiusRatio*Inputs.StartingRadius;                %Update flux        ListNodes.(evaluatednode).flux = CalculateFlux(Inputs,ListNodes.(evaluatednode));    endendend