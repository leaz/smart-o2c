function [ListNodes] = GrowthFactor(Inputs, ListNodes, Solutions)% This function finds the best chain of veins used by the agents and% increases the radius of these vains by a pre-specified factor%% Inputs:% * Inputs         : Structure containing the PhysarumSolver inputs% * ListNodes      : Structure containing the graph% * Solutions      : Structure containing the solutions so far%% Outputs: % * ListNodes       : Structure containing the updated graph%% Author: Aram Vroom - 2016% Email:  aram.vroom@strath.ac.uk%Atira Specific Attempt 1%Normalize cost for # of nodes & for dV to find solution w. the most%asteroids% sumNodes = sum(numberofnodes);% totalsumCosts = sum(costs);% % numberofnodecost = (sumNodes./numberofnodes)./sum(sumNodes./numberofnodes);% solutioncosts = costs./totalsumCosts;% % totalcost = 0.8*numberofnodecost+0.2*solutioncosts;%!!Atira Specific Attempt 2%Find solutions with the most asteroids and the minimum cost%Loop over the solutions and find the number of nodes and costsfor i = 1:length(Solutions.Nodes)    numberofnodes(i) = length(Solutions.Nodes{i});    costs(i) = sum(Solutions.Costs{i});end%Find the index of the solution(s) with the most asteroidsmaxasteroidnumindex = find(numberofnodes==max(numberofnodes));%Find the corresponding cost(s)maxasteroidcosts = costs([maxasteroidnumindex]);%Obtain the index of the minimum costminimumcostindex = find(maxasteroidcosts==min(maxasteroidcosts));%Find the index of the solution with the moster asteroids and the minimum%costmaxasteroidminimumcostindex = maxasteroidnumindex(minimumcostindex);%Retrieve the best chain of nodesbestchain = Solutions.Nodes{maxasteroidminimumcostindex};%Print the best solution so fardisp('-------------------------------------------------------')disp(['The best chain so far has ',num2str(length(bestchain)),' nodes and a cost of ',num2str(maxasteroidcosts(minimumcostindex))]);disp('-------------------------------------------------------')%Non-Atira specific% for i = 1:length(Solutions.Nodes)% totalcost(i) = sum(Solutions.Costs{i});% end%Find the minimum cost%[~, mincostindex] = min(totalcost);%Determine which chain is the best%bestchain = Solutions.Nodes{mincostindex};%Loop over the nodes in this chainfor i = 1:length(bestchain)        %For ease of reading, define the node currently being evaluated & its parent    %as a separate variable    evaluatednode = char(bestchain(i));    parent = ListNodes.(evaluatednode).parent;        %Check if the node has a parent - Ignores root    if ~isempty(parent)                %Dilate the respective link in the parent's node structure        ListNodes.(evaluatednode).radius = ListNodes.(evaluatednode).radius + Inputs.GrowthFactor*ListNodes.(evaluatednode).radius;               %Check if the link's radius is not too large or small. Correct if        %so, set to min/max radius        ListNodes.(evaluatednode).radius(ListNodes.(evaluatednode).radius./Inputs.StartingRadius > Inputs.MaximumRadiusRatio) = Inputs.MaximumRadiusRatio*Inputs.StartingRadius;        ListNodes.(evaluatednode).radius(ListNodes.(evaluatednode).radius./Inputs.StartingRadius < Inputs.MinimumRadiusRatio) = Inputs.MinimumRadiusRatio*Inputs.StartingRadius;    endend